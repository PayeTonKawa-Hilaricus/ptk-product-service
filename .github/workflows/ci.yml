name: üõ°Ô∏è CI/CD Pipeline - Quality & Security

on:
  push:
    branches: ['main', 'develop']
  pull_request:
    branches: ['main', 'develop']

jobs:
  # ===========================================================================
  # JOB 1: QUALITY CONTROL & SECURITY BASICS
  # Linting, Formatting, Dependency Audit, Secret Detection
  # ===========================================================================
  quality-check:
    name: üîç Quality & Secrets
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Important pour Gitleaks (scan historique)

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      # 1. Formatage (Prettier)
      - name: üé® Check Formatting
        run: npx prettier --check .

      # 2. Linting Strict (ESLint)
      - name: üßπ Linting Strict
        run: npm run lint

      # 3. Audit des d√©pendances (Vuln√©rabilit√©s connues)
      - name: üïµÔ∏è Dependency Audit
        run: npm audit --audit-level=high
        continue-on-error: true # On alerte mais on ne bloque pas forc√©ment tout de suite

      # 4. D√©tection de Secrets (Remplacement : TruffleHog au lieu de Gitleaks)
      - name: üê∑ TruffleHog OSS
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          extra_args: --debug --only-verified --no-verification 

  # ===========================================================================
  # JOB 2: TESTING (UNIT, INTEGRATION, CONTRACT)
  # N√©cessite une base de donn√©es temporaire pour les tests d'int√©gration
  # ===========================================================================
  testing:
    name: üß™ Test Suite
    runs-on: ubuntu-latest
    needs: quality-check # On ne teste que si la qualit√© est OK

    # Service Container : On lance un Postgres pour les tests E2E
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        # Healthcheck pour attendre que la DB soit pr√™te
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      # 1. Tests Unitaires
      - name: üß© Unit Tests
        run: npm run test -- --coverage

      # 2. Tests d'Int√©gration (E2E)
      # On injecte les variables d'env pour se connecter au Service Postgres ci-dessus
      - name: üîó Integration Tests (E2E)
        run: npm run test:e2e
        env:
          # Prisma a besoin de TOUT en une seule ligne :
          # postgresql://USER:PASSWORD@HOST:PORT/DB_NAME?schema=public
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_db?schema=public

      # 3. Contract Testing (Pact)
      # Note: Ne s'ex√©cute que si le script existe dans package.json
      - name: ü§ù Contract Testing (Pact)
        run: |
          if npm run | grep -q "test:pact"; then
            npm run test:pact
          else
            echo "‚ö†Ô∏è Pas de script 'test:pact' d√©tect√©, √©tape ignor√©e."
          fi

  # ===========================================================================
  # JOB 3: ADVANCED SECURITY (SAST)
  # Analyse statique du code pour trouver des failles de s√©curit√© logiques
  # ===========================================================================
  sast-analysis:
    name: üõ°Ô∏è SAST (CodeQL)
    runs-on: ubuntu-latest
    needs: quality-check
    permissions:
      security-events: write # Obligatoire pour uploader les rapports
      actions: read
      contents: read

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript # NestJS = Typescript/Javascript

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  # ===========================================================================
  # JOB 4: DELIVERY (BUILD DOCKER)
  # V√©rifie que l'image Docker se construit bien (sans la pousser pour l'instant)
  # ===========================================================================
  docker-build:
    name: üê≥ Docker Build Check
    runs-on: ubuntu-latest
    needs: [testing, sast-analysis] # On ne build que si tout est vert

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false # On ne push pas sur le Hub pour l'instant, on v√©rifie juste le build
          tags: payetonkawa/service:latest

  deploy-pc2:
    name: üöÄ Deploy on PC2
    # S√âCURIT√â MAXIMALE : On attend que TOUT soit vert (Tests + S√©curit√© + Build Docker)
    needs: [testing, sast-analysis, docker-build]
    if: github.ref == 'refs/heads/main'
    runs-on: [self-hosted, production-pc]

    steps:
      - name: üöö Checkout Code
        uses: actions/checkout@v4

      - name: üîÑ Update & Restart Service
        shell: pwsh
        run: |
          # --- CONFIGURATION ---
          $ROOT = "C:\PayeTonKawa"
          $INFRA_DIR = "$ROOT\ptk-infrastructure"
          $SERVICE_NAME = "${{ github.event.repository.name }}"

          Write-Host "üî• D√âBUT DU D√âPLOIEMENT : $SERVICE_NAME"

          # 1. Mise √† jour du code source du Micro-Service
          Write-Host "üì• Pull du code source..."
          cd "$ROOT\$SERVICE_NAME"
          git fetch origin
          git reset --hard origin/main

          # 2. Mise √† jour de l'Infrastructure
          # C'est ICI qu'on va travailler pour la suite
          Write-Host "üèóÔ∏è Mise √† jour de l'infra..."
          cd $INFRA_DIR
          git pull origin main

          # 3. G√©n√©ration du .env DANS le dossier INFRA (l√† o√π est le docker-compose)
          Write-Host "üîë G√©n√©ration des secrets..."

          # On nettoie l'ancien .env pour √™tre s√ªr
          if (Test-Path .env) { Remove-Item .env }

          if ($SERVICE_NAME -eq "ptk-auth-service") {
             echo "DATABASE_URL=${{ secrets.AUTH_DATABASE_URL }}" >> .env
             echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
             echo "RABBITMQ_URL=${{ secrets.RABBITMQ_URL }}" >> .env
             echo "PORT=3000" >> .env
          }
          elseif ($SERVICE_NAME -eq "ptk-product-service") {
             echo "DATABASE_URL=${{ secrets.PRODUCT_DATABASE_URL }}" >> .env
             echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
             echo "RABBITMQ_URL=${{ secrets.RABBITMQ_URL }}" >> .env
             echo "PORT=3002" >> .env
          }
          elseif ($SERVICE_NAME -eq "ptk-order-service") {
             echo "DATABASE_URL=${{ secrets.ORDER_DATABASE_URL }}" >> .env
             echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
             echo "RABBITMQ_URL=${{ secrets.RABBITMQ_URL }}" >> .env
             echo "PORT=3001" >> .env
          }
          elseif ($SERVICE_NAME -eq "ptk-client-service") {
             echo "DATABASE_URL=${{ secrets.CLIENT_DATABASE_URL }}" >> .env
             echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
             echo "RABBITMQ_URL=${{ secrets.RABBITMQ_URL }}" >> .env
             echo "PORT=3003" >> .env
          }

          # 4. Relancer le conteneur (Depuis le dossier INFRA)
          Write-Host "üê≥ Red√©marrage du conteneur..."
          docker-compose up -d --build --no-deps $SERVICE_NAME

          # 5. Nettoyage
          docker image prune -f

          Write-Host "‚úÖ Succ√®s ! $SERVICE_NAME est d√©ploy√©."
